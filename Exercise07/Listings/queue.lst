


ARM Macro Assembler    Page 1 Exercise 07 Circular FIFO Queue Operations


    1 00000000                 TTL              Exercise 07 Circular FIFO Queue
 Operations
    2 00000000         
    3 00000000         ;*******************************************************
                       *********
    4 00000000         ;Date:  10/01/2015
    5 00000000         ;Class:  CMPE-250
    6 00000000         ;Section:  03 TR 2-4PM
    7 00000000         ;-------------------------------------------------------
                       --------
    8 00000000         ;Keil Template for KL46
    9 00000000         ;R. W. Melton
   10 00000000         ;April 3, 2015
   11 00000000         ;*******************************************************
                       *********
   12 00000000         ;Assembler directives
   13 00000000                 THUMB
   15 00000000         ;*******************************************************
                       *********
   16 00000000         ;Include files
   17 00000000                 GET              MKL46Z4.s   ;Included by start.
                                                            s
   19 00000000         ;*******************************************************
                       *********
   20 00000000         ;EQUates
   21 00000000         
   22 00000000         ;-------------------------------------------------------
                       --------
   23 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   24 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   25 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   26 00000000         ;-------------------------------------------------------
                       --------
   27 00000000         ;Port A
   29 00000000 01000200 
                       PORT_PCR_SET_PTA1_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR:       
                             PORT_PCR_MUX_SELECT_2_MASK)
   31 00000000 01000200 
                       PORT_PCR_SET_PTA2_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR:       
                             PORT_PCR_MUX_SELECT_2_MASK)
   32 00000000         ;-------------------------------------------------------
                       --------
   33 00000000         ;SIM_SCGC4
   34 00000000         ;1->10:UART0 clock gate control (enabled)
   35 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   36 00000000         ;-------------------------------------------------------
                       --------
   37 00000000         ;SIM_SCGC5
   38 00000000         ;1->09:Port A clock gate control (enabled)
   39 00000000         ;Use provided SIM_SCGC5_PORTA_MASK
   40 00000000         ;-------------------------------------------------------
                       --------
   41 00000000         ;SIM_SOPT2
   42 00000000         ;01=27-26:UART0SRC=UART0 clock source select
   43 00000000         ;         (PLLFLLSEL determines MCGFLLCLK' or MCGPLLCLK/
                       2)
   44 00000000         ; 1=   16:PLLFLLSEL=PLL/FLL clock select (MCGPLLCLK/2)



ARM Macro Assembler    Page 2 Exercise 07 Circular FIFO Queue Operations


   46 00000000 04000000 
                       SIM_SOPT2_UART0SRC_MCGPLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
   48 00000000 04010000 
                       SIM_SOPT2_UART0_MCGPLLCLK_DIV2
                               EQU              (SIM_SOPT2_UART0SRC_MCGPLLCLK :
OR: SIM_SOPT2_PLLFLLSEL_MASK)
   49 00000000         ;-------------------------------------------------------
                       --------
   50 00000000         ;SIM_SOPT5
   51 00000000         ; 0->   16:UART0 open drain enable (disabled)
   52 00000000         ; 0->   02:UART0 receive data select (UART0_RX)
   53 00000000         ;00->01-00:UART0 transmit data select source (UART0_TX)
   57 00000000 00010007 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR:  
                                SIM_SOPT5_UART0RXSRC_MASK :OR:               
                   SIM_SOPT5_UART0TXSRC_MASK)
   58 00000000         ;-------------------------------------------------------
                       --------
   59 00000000         ;UART0_BDH
   60 00000000         ;    0->  7:LIN break detect IE (disabled)
   61 00000000         ;    0->  6:RxD input active edge IE (disabled)
   62 00000000         ;    0->  5:Stop bit number select (1)
   63 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
   64 00000000         ;UART0CLK is MCGPLLCLK/2
   65 00000000         ;MCGPLLCLK is 96 MHz
   66 00000000         ;MCGPLLCLK/2 is 48 MHz
   67 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   68 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
   69 00000000         ;-------------------------------------------------------
                       --------
   70 00000000         ;UART0_BDL
   71 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
   72 00000000         ;UART0CLK is MCGPLLCLK/2
   73 00000000         ;MCGPLLCLK is 96 MHz
   74 00000000         ;MCGPLLCLK/2 is 48 MHz
   75 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   76 00000000 00000038 
                       UART0_BDL_9600
                               EQU              0x38
   77 00000000         ;-------------------------------------------------------
                       --------
   78 00000000         ;UART0_C1
   79 00000000         ;0-->7:LOOPS=loops select (normal)
   80 00000000         ;0-->6:DOZEEN=doze enable (disabled)
   81 00000000         ;0-->5:RSRC=receiver source select (internal--no effect 
                       LOOPS=0)
   82 00000000         ;0-->4:M=9- or 8-bit mode select 
   83 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
   84 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
   85 00000000         ;0-->2:IDLE=idle line type select (idle begins after sta
                       rt bit)
   86 00000000         ;0-->1:PE=parity enable (disabled)
   87 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
   88 00000000 00000000 
                       UART0_C1_8N1



ARM Macro Assembler    Page 3 Exercise 07 Circular FIFO Queue Operations


                               EQU              0x00
   89 00000000         ;-------------------------------------------------------
                       --------
   90 00000000         ;UART0_C2
   91 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
   92 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
   93 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
   94 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
   95 00000000         ;1-->3:TE=transmitter enable (enabled)
   96 00000000         ;1-->2:RE=receiver enable (enabled)
   97 00000000         ;0-->1:RWU=receiver wakeup control (normal)
   98 00000000         ;0-->0:SBK=send break (disabled, normal)
   99 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2
_RE_MASK)
  100 00000000         ;-------------------------------------------------------
                       --------
  101 00000000         ;UART0_C3
  102 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  103 00000000         ;           10th data bit for transmitter (not used M10=
                       0)
  104 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
  105 00000000         ;           10th data bit for receiver (not used M10=0)
  106 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
  107 00000000         ;            (no effect LOOPS=0)
  108 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
  109 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  110 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  111 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
  112 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  113 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
  114 00000000         ;-------------------------------------------------------
                       --------
  115 00000000         ;UART0_C4
  116 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled
                       )
  117 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled
                       )
  118 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  119 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  120 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  121 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)
  122 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  123 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  124 00000000         ;-------------------------------------------------------
                       --------
  125 00000000         ;UART0_C5
  126 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  127 00000000         ;  0-->  6:Reserved; read-only; always 0
  128 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)
  129 00000000         ;000-->4-2:Reserved; read-only; always 0
  130 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only



ARM Macro Assembler    Page 4 Exercise 07 Circular FIFO Queue Operations


                       )
  131 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
                       
  132 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  133 00000000         ;-------------------------------------------------------
                       --------
  134 00000000         ;UART0_S1
  135 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
                       
  136 00000000         ;0-->6:TC=transmission complete flag; read-only
  137 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  138 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  139 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear
                       )
  140 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  141 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  142 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  143 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              0x1F
  144 00000000         ;-------------------------------------------------------
                       --------
  145 00000000         ;UART0_S2
  146 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  147 00000000         ;             write 1 to clear
  148 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear
                       )
  149 00000000         ;              write 1 to clear
  150 00000000         ;0-->5:(reserved); read-only; always 0
  151 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  152 00000000         ;0-->3:RWUID=receive wake-up idle detect
  153 00000000         ;0-->2:BRK13=break character generation length (10)
  154 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  155 00000000         ;0-->0:RAF=receiver active flag; read-only
  156 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              0xC0
  157 00000000         ;-------------------------------------------------------
                       --------
  158 00000000         
  159 00000000         ;Max length of queue
  160 00000000 00000050 
                       Q_BUF_SZ
                               EQU              80
  161 00000000 00000012 
                       Q_REC_SZ
                               EQU              18
  162 00000000         
  163 00000000         ;Max length of prompt string
  164 00000000 0000004F 
                       MAX_STRING
                               EQU              79
  165 00000000         
  166 00000000 00000000 
                       IN_PTR  EQU              0
  167 00000000 00000004 
                       OUT_PTR EQU              4



ARM Macro Assembler    Page 5 Exercise 07 Circular FIFO Queue Operations


  168 00000000 00000008 
                       BUF_START
                               EQU              8
  169 00000000 0000000C 
                       BUF_PAST
                               EQU              12
  170 00000000 00000010 
                       BUF_SIZE
                               EQU              16
  171 00000000 00000011 
                       NUM_ENQD
                               EQU              17
  172 00000000         
  173 00000000         ;*******************************************************
                       *********
  174 00000000         ;Program
  175 00000000         ;Linker requires Reset_Handler
  176 00000000                 AREA             MyCode,CODE,READONLY
  177 00000000                 ENTRY
  178 00000000                 EXPORT           Reset_Handler
  179 00000000                 IMPORT           Startup
  180 00000000         Reset_Handler
  181 00000000         main
  182 00000000         ;-------------------------------------------------------
                       --------
  183 00000000         ;Mask interrupts
  184 00000000 B672            CPSID            I
  185 00000002         ;KL46 system startup with 48-MHz system clock
  186 00000002 F7FF FFFE       BL               Startup
  187 00000006 F000 F8DC       BL               Init_UART0_Polling
  188 0000000A         ;-------------------------------------------------------
                       --------
  189 0000000A         ;>>>>> begin main program code <<<<<
  190 0000000A         
  191 0000000A         ;Load input params to initalize queue structure
  192 0000000A 4989            LDR              R1, =QueueRecord
  193 0000000C 4889            LDR              R0, =Queue
  194 0000000E 2250            MOVS             R2, #Q_BUF_SZ
  195 00000010         
  196 00000010         ;Initalize Queue structure once variables are loaded
  197 00000010 F000 F81E       BL               InitQueue
  198 00000014         
  199 00000014 2005            MOVS             R0, #5
  200 00000016 F000 F847       BL               EnQueue
  201 0000001A         
  202 0000001A 2008            MOVS             R0, #8
  203 0000001C F000 F844       BL               EnQueue
  204 00000020         
  205 00000020 200A            MOVS             R0, #10
  206 00000022 F000 F841       BL               EnQueue
  207 00000026         
  208 00000026         ;>>>>>   end main program code <<<<<
  209 00000026         ;Stay here
  210 00000026 E7FE            B                .
  211 00000028         ;>>>>> begin subroutine code <<<<<
  212 00000028         
  213 00000028         PutNumHex
  214 00000028         ;PutNumHex: Print hex representation of a value
  215 00000028         ;To the console. Separates each nibble via masking



ARM Macro Assembler    Page 6 Exercise 07 Circular FIFO Queue Operations


  216 00000028         ;And then converts to appropriate ASCII representation
  217 00000028         ;Inputs:
  218 00000028         ;R0 - Value to print to the screen
  219 00000028         ;Outputs: N/A
  220 00000028         ;--------------------------------------------
  221 00000028 B50C            PUSH             {R2, R3, LR}
  222 0000002A         
  223 0000002A 2200            MOVS             R2, #0
  224 0000002C         
  225 0000002C         HEX_PRINT_LOOP
  226 0000002C         
  227 0000002C         ;Iterate 8 times for each digit stored in a register
  228 0000002C 2A07            CMP              R2, #7
  229 0000002E D00E            BEQ              END_PRINT_HEX
  230 00000030         
  231 00000030         ;Shift current nibble to print to
  232 00000030         ;the rightmost value of register
  233 00000030 0003            MOVS             R3, R0
  234 00000032 40D3            LSRS             R3, R2
  235 00000034         
  236 00000034         ;Convert to appropriate ASCII value
  237 00000034 2B0A            CMP              R3, #10
  238 00000036 DA01            BGE              PRINT_LETTER
  239 00000038         
  240 00000038         ;If 0-9 should be printed, add ASCII '0' val
  241 00000038 3330            ADDS             R3, #'0'
  242 0000003A E000            B                PRINT_CHAR
  243 0000003C         
  244 0000003C         PRINT_LETTER
  245 0000003C         
  246 0000003C         ;If A-F should be printed, Add ASCII '55'
  247 0000003C         ;To convert to capital letter value
  248 0000003C 3337            ADDS             R3, R3, #55
  249 0000003E         
  250 0000003E         PRINT_CHAR
  251 0000003E         ;Print ASCII value to the screen
  252 0000003E         ;Make sure not to destroy vlue in R0!
  253 0000003E B401            PUSH             {R0}
  254 00000040 0018            MOVS             R0, R3
  255 00000042 F000 F855       BL               PutChar
  256 00000046 BC01            POP              {R0}
  257 00000048         
  258 00000048         ;Reset value in R3 and increment loop counter
  259 00000048 2300            MOVS             R3, #0
  260 0000004A 1C52            ADDS             R2, R2, #1
  261 0000004C E7EE            B                HEX_PRINT_LOOP
  262 0000004E         
  263 0000004E         END_PRINT_HEX
  264 0000004E         
  265 0000004E BD0C            POP              {R2, R3, PC}
  266 00000050         ;--------------------------------------------
  267 00000050         
  268 00000050         InitQueue
  269 00000050         ;InitQueue: Initalize Circular FIFO Queue Structure
  270 00000050         ;Inputs:
  271 00000050         ;R0 - Memory location of queue buffer
  272 00000050         ;R1 - Address to place Queue record structure
  273 00000050         ;R2 - Size of queue structure (character capacity)
  274 00000050         ;Outputs: N/A



ARM Macro Assembler    Page 7 Exercise 07 Circular FIFO Queue Operations


  275 00000050         ;--------------------------------------------
  276 00000050         
  277 00000050         ;Store memory address of front of queue
  278 00000050         ;Into IN_PTR position of the buffer
  279 00000050 6008            STR              R0, [R1, #IN_PTR]
  280 00000052         
  281 00000052         ;Store same memory address for OUT_PTR
  282 00000052         ;position in the buffer since queue is empty
  283 00000052 6048            STR              R0, [R1, #OUT_PTR]
  284 00000054         
  285 00000054         ;Store same memory address in BUF_START for initalizatio
                       n
  286 00000054 6088            STR              R0, [R1, #BUF_START]
  287 00000056         
  288 00000056         ;Store BUF_PAST in last slot of buffer
  289 00000056 1880            ADDS             R0, R0, R2
  290 00000058 60C8            STR              R0, [R1, #BUF_PAST]
  291 0000005A         
  292 0000005A         ;Store BUF_SIZE with size in R2
  293 0000005A 610A            STR              R2, [R1, #BUF_SIZE]
  294 0000005C         
  295 0000005C         ;Initalize NUM_ENQD to zero and 
  296 0000005C         ;store in 6th slot of buffer
  297 0000005C 2000            MOVS             R0, #0
  298 0000005E 7448            STRB             R0, [R1, #NUM_ENQD]
  299 00000060         
  300 00000060 4770            BX               LR
  301 00000062         
  302 00000062         ;--------------------------------------------
  303 00000062         
  304 00000062         DeQueue
  305 00000062         ;DeQueue: Remove an element from the circular FIFO Queue
                       
  306 00000062         ;Inputs:
  307 00000062         ;R1 - Address of Queue record structure
  308 00000062         ;Outputs:
  309 00000062         ;R0 - Character that has been dequeued
  310 00000062         ;PSR C flag (failure if C = 1, C = 0 otherwise.)
  311 00000062         ;--------------------------------------------
  312 00000062 B41C            PUSH             {R2, R3, R4}
  313 00000064         
  314 00000064         ;If the number enqueued is 0,
  315 00000064         ;Set failure PSR flag
  316 00000064 7C4B            LDRB             R3, [R1, #NUM_ENQD]
  317 00000066 2B00            CMP              R3, #0
  318 00000068 DD15            BLE              DEQUEUE_FAILURE
  319 0000006A         
  320 0000006A         ;Remove the item from the queue
  321 0000006A         ;And place in R0
  322 0000006A 6848            LDR              R0, [R1, #OUT_PTR]
  323 0000006C         ;Load actual queue value into R0
  324 0000006C 6800            LDR              R0, [R0, #0]
  325 0000006E         
  326 0000006E         ;Decrement number of enqueued elements
  327 0000006E         ;And store info back in buffer
  328 0000006E 7C4B            LDRB             R3, [R1, #NUM_ENQD]
  329 00000070 1E5B            SUBS             R3, R3, #1
  330 00000072 744B            STRB             R3, [R1, #NUM_ENQD]
  331 00000074         



ARM Macro Assembler    Page 8 Exercise 07 Circular FIFO Queue Operations


  332 00000074         ;Increment location of out_pointer
  333 00000074 684B            LDR              R3, [R1, #OUT_PTR]
  334 00000076 1D1B            ADDS             R3, R3, #4
  335 00000078 604B            STR              R3, [R1, #OUT_PTR]
  336 0000007A         
  337 0000007A         ;Compare OUT_PTR to BUF_PAST
  338 0000007A         ;If out_ptr >= BUF_PAST, wrap the queue around
  339 0000007A 68CC            LDR              R4, [R1, #BUF_PAST]
  340 0000007C 42A3            CMP              R3, R4
  341 0000007E DA00            BGE              WRAP_BUFFER
  342 00000080 E001            B                DEQUEUE_CLEAR_PSR
  343 00000082         
  344 00000082         WRAP_BUFFER
  345 00000082         ;Adjust out_ptr to equal buf_start
  346 00000082         ;Thus wrapping around the circular queue
  347 00000082 688B            LDR              R3, [R1, #BUF_START]
  348 00000084 604A            STR              R2, [R1, #OUT_PTR]
  349 00000086         
  350 00000086         DEQUEUE_CLEAR_PSR
  351 00000086         ;Clear the PSR C flag
  352 00000086 F3EF 8100       MRS              R1, APSR
  353 0000008A 2320            MOVS             R3, #0x20
  354 0000008C 0609            LSLS             R1, R1, #24
  355 0000008E 4399            BICS             R1, R1, R3
  356 00000090 F381 8800       MSR              APSR, R1
  357 00000094         
  358 00000094         ;Successfully end the operation
  359 00000094 E006            B                END_DEQUEUE
  360 00000096         
  361 00000096         DEQUEUE_FAILURE
  362 00000096         ;Set PSR C flag to 1
  363 00000096 F3EF 8100       MRS              R1, APSR
  364 0000009A 2320            MOVS             R3, #0x20
  365 0000009C 061B            LSLS             R3, R3, #24
  366 0000009E 4319            ORRS             R1, R1, R3
  367 000000A0 F381 8800       MSR              APSR, R1
  368 000000A4         
  369 000000A4         END_DEQUEUE
  370 000000A4 BC1C            POP              {R2, R3, R4}
  371 000000A6 4770            BX               LR
  372 000000A8         
  373 000000A8         ;--------------------------------------------
  374 000000A8         EnQueue
  375 000000A8         ;EnQueue: Add an element to the circular FIFO Queue
  376 000000A8         ;Inputs:
  377 000000A8         ;R0 - Character to enqueue
  378 000000A8         ;R1 - Address of the Queue record
  379 000000A8         ;Outputs:
  380 000000A8         ;PSR C flag (failure if C = 1, C = 0 otherwise.)
  381 000000A8         ;--------------------------------------------'
  382 000000A8         
  383 000000A8 B41C            PUSH             {R2, R3, R4}
  384 000000AA         
  385 000000AA         ;If num_enqd >= size of the queue
  386 000000AA         ;Then set PSR C flag to 1 indicating
  387 000000AA         ;the error that an element was not inserted
  388 000000AA         ;into a full queue
  389 000000AA         
  390 000000AA 7C4B            LDRB             R3, [R1, #NUM_ENQD]



ARM Macro Assembler    Page 9 Exercise 07 Circular FIFO Queue Operations


  391 000000AC 690C            LDR              R4, [R1, #BUF_SIZE]
  392 000000AE 42A3            CMP              R3, R4
  393 000000B0 DA00            BGE              QUEUE_FULL
  394 000000B2 E007            B                BEGIN_ENQUEUE
  395 000000B4         
  396 000000B4         QUEUE_FULL
  397 000000B4         ;Set PSR C flag to 1
  398 000000B4 F3EF 8100       MRS              R1, APSR
  399 000000B8 2320            MOVS             R3, #0x20
  400 000000BA 061B            LSLS             R3, R3, #24
  401 000000BC 4319            ORRS             R1, R1, R3
  402 000000BE F381 8800       MSR              APSR, R1
  403 000000C2 E013            B                END_ENQUEUE
  404 000000C4         
  405 000000C4         BEGIN_ENQUEUE
  406 000000C4         
  407 000000C4         ;Load mem address of in_ptr
  408 000000C4         ;and then store the value to be enqueued
  409 000000C4         ;intot he value at that memory address
  410 000000C4 680B            LDR              R3, [R1, #IN_PTR]
  411 000000C6 6018            STR              R0, [R3, #0]
  412 000000C8         
  413 000000C8         ;Increment value of in_ptr by 4, 1 value past
  414 000000C8         ;The queue item. Then store back in IN_PTR
  415 000000C8 1D1B            ADDS             R3, R3, #4
  416 000000CA 600B            STR              R3, [R1, #IN_PTR]
  417 000000CC         
  418 000000CC         ;Increment number of enqueued elements
  419 000000CC 7C4B            LDRB             R3, [R1, #NUM_ENQD]
  420 000000CE 1C5B            ADDS             R3, R3, #1
  421 000000D0 744B            STRB             R3, [R1, #NUM_ENQD]
  422 000000D2         
  423 000000D2         ;If IN_PTR is >= BUF_PAST
  424 000000D2         ;Loop around and adjust inPtr to beginning of
  425 000000D2         ;the queue buffer
  426 000000D2 680B            LDR              R3, [R1, #IN_PTR]
  427 000000D4 68CC            LDR              R4, [R1, #BUF_PAST]
  428 000000D6         
  429 000000D6 42A3            CMP              R3, R4
  430 000000D8 DA00            BGE              WRAP_ENQUEUE
  431 000000DA E007            B                END_ENQUEUE
  432 000000DC         
  433 000000DC         WRAP_ENQUEUE
  434 000000DC         ;Adjust in_ptr to beginning of queue buffer
  435 000000DC 6011            STR              R1, [R2, #IN_PTR]
  436 000000DE         
  437 000000DE         ;Clear the PSR C flag confirming successful result
  438 000000DE F3EF 8200       MRS              R2, APSR
  439 000000E2 2320            MOVS             R3, #0x20
  440 000000E4 0612            LSLS             R2, R2, #24
  441 000000E6 439A            BICS             R2, R2, R3
  442 000000E8 F382 8800       MSR              APSR, R2
  443 000000EC         
  444 000000EC         END_ENQUEUE
  445 000000EC         
  446 000000EC BC1C            POP              {R2, R3, R4}
  447 000000EE 4770            BX               LR
  448 000000F0         
  449 000000F0         ;--------------------------------------------



ARM Macro Assembler    Page 10 Exercise 07 Circular FIFO Queue Operations


  450 000000F0         
  451 000000F0         ;Send a character out of UART0
  452 000000F0         ;--------------------------------------------
  453 000000F0         PutChar
  454 000000F0 B40E            PUSH             {R1, R2, R3} ; Push varibles on
                                                             the stack to avoid
                                                             loss
  455 000000F2         
  456 000000F2         ;Poll TDRE Until UART0 is ready for transmit
  457 000000F2 4951            LDR              R1, =UART0_BASE
  458 000000F4 2280            MOVS             R2, #UART0_S1_TDRE_MASK
  459 000000F6         
  460 000000F6         PollTx
  461 000000F6 790B            LDRB             R3, [R1, #UART0_S1_OFFSET]
  462 000000F8 4013            ANDS             R3, R3, R2
  463 000000FA D0FC            BEQ              PollTx
  464 000000FC         
  465 000000FC         ;Transmit Character Stored in R0
  466 000000FC 71C8            STRB             R0, [R1, #UART0_D_OFFSET]
  467 000000FE         
  468 000000FE         ;Pop original register values off the stack
  469 000000FE BC0E            POP              {R1, R2, R3}
  470 00000100         
  471 00000100 4770            BX               LR
  472 00000102         ;--------------------------------------------
  473 00000102         
  474 00000102         ;Receive a character from UART0
  475 00000102         ;Store in Register R0
  476 00000102         ;--------------------------------------------
  477 00000102         GetChar
  478 00000102 B406            PUSH             {R1, R2}    ; Push varibles on 
                                                            the stack to avoid 
                                                            loss
  479 00000104 494C            LDR              R1, =UART0_BASE
  480 00000106 2220            MOVS             R2, #UART0_S1_RDRF_MASK
  481 00000108         PollRx
  482 00000108 790B            LDRB             R3, [R1, #UART0_S1_OFFSET]
  483 0000010A 4013            ANDS             R3, R3, R2
  484 0000010C D0FC            BEQ              PollRx
  485 0000010E         
  486 0000010E         ;Receive character and store in R0
  487 0000010E 79CB            LDRB             R3, [R1, #UART0_D_OFFSET]
  488 00000110         
  489 00000110 BC06            POP              {R1, R2}
  490 00000112 4770            BX               LR
  491 00000114         
  492 00000114         ;--------------------------------------------
  493 00000114         
  494 00000114         ;R0 = memory location to store string
  495 00000114         ;R1 = Buffer capacity (numChars)
  496 00000114         
  497 00000114         ;--------------------------------------------
  498 00000114         GetStringSB
  499 00000114         
  500 00000114 B50E            PUSH             {R1, R2, R3, LR}
  501 00000116 2200            MOVS             R2, #0      ;Initalize string o
                                                            ffset to zero
  502 00000118         
  503 00000118         



ARM Macro Assembler    Page 11 Exercise 07 Circular FIFO Queue Operations


  504 00000118         TAKE_INPUT
  505 00000118         
  506 00000118         ;Grab the next character of input and store in R3
  507 00000118 F7FF FFF3       BL               GetChar
  508 0000011C         
  509 0000011C         ;check if character is a carrige return
  510 0000011C 2B0D            CMP              R3, #13
  511 0000011E D00A            BEQ              END_GET_STR
  512 00000120         
  513 00000120         ;If all characters have been processed
  514 00000120         ;and another comes in, dont echo and reset.
  515 00000120 2900            CMP              R1, #0
  516 00000122 D0F9            BEQ              TAKE_INPUT
  517 00000124         
  518 00000124         ;Echo character to the terminal
  519 00000124 B401            PUSH             {R0}        ;Preserve state of 
                                                            R0 and LR
  520 00000126 0018            MOVS             R0, R3      ;Move char in R3 fo
                                                            r transit
  521 00000128 F7FF FFE2       BL               PutChar
  522 0000012C BC01            POP              {R0}
  523 0000012E         
  524 0000012E         ;String[i] = input char
  525 0000012E 5483            STRB             R3, [R0, R2]
  526 00000130         
  527 00000130         ;Decrement number of characters left to read
  528 00000130 1E49            SUBS             R1, R1, #1
  529 00000132         ;Add to offset index for string
  530 00000132 1C52            ADDS             R2, R2, #1
  531 00000134         
  532 00000134 E7F0            B                TAKE_INPUT
  533 00000136         
  534 00000136         END_GET_STR
  535 00000136         
  536 00000136         ;null terminate String
  537 00000136 2300            MOVS             R3, #0
  538 00000138 5483            STRB             R3, [R0, R2]
  539 0000013A         
  540 0000013A         ;Pop PC returns nested subroutine
  541 0000013A BD0E            POP              {R1, R2, R3, PC}
  542 0000013C         
  543 0000013C         
  544 0000013C         PrintCharLF
  545 0000013C         ;Print character in R0
  546 0000013C         ;In addition to a carrige return and a line feed
  547 0000013C         ;Used to produce the command 'menu' with single char inp
                       uts
  548 0000013C         
  549 0000013C B501            PUSH             {R0, LR}
  550 0000013E         ;Echo the char back to the user
  551 0000013E F7FF FFD7       BL               PutChar
  552 00000142         
  553 00000142         ;Print CR and LF to the screen
  554 00000142 200D            MOVS             R0, #0x0D
  555 00000144 F7FF FFD4       BL               PutChar
  556 00000148         
  557 00000148 200A            MOVS             R0, #0x0A
  558 0000014A F7FF FFD1       BL               PutChar
  559 0000014E         



ARM Macro Assembler    Page 12 Exercise 07 Circular FIFO Queue Operations


  560 0000014E BD01            POP              {R0, PC}
  561 00000150         
  562 00000150         ;--------------------------------------------
  563 00000150         
  564 00000150         ;R0 = memory location of string to print
  565 00000150         ;R1 = Buffer capacity (numChars)
  566 00000150         PutStringSB
  567 00000150         ;--------------------------------------------
  568 00000150         
  569 00000150 B50A            PUSH             {R1, R3, LR}
  570 00000152         
  571 00000152         ;Determine the length of the string before printing
  572 00000152 F000 F80D       BL               LengthStringSB
  573 00000156 0011            MOVS             R1, R2
  574 00000158         
  575 00000158         READ_CHAR
  576 00000158         
  577 00000158         ;If all characters have been processed
  578 00000158         ;End subroutine execution
  579 00000158 2900            CMP              R1, #0
  580 0000015A D008            BEQ              END_PUT_STR
  581 0000015C         
  582 0000015C         ;Grab the next character of input and store in R3
  583 0000015C 7803            LDRB             R3, [R0, #0]
  584 0000015E         
  585 0000015E         ;Echo character to the terminal
  586 0000015E B401            PUSH             {R0}        ;Preserve state of 
                                                            R0 and LR
  587 00000160 0018            MOVS             R0, R3      ;Move char in R3 fo
                                                            r transit
  588 00000162 F7FF FFC5       BL               PutChar
  589 00000166 BC01            POP              {R0}
  590 00000168         
  591 00000168         ;Decrement number of characters left to read
  592 00000168 1E49            SUBS             R1, R1, #1
  593 0000016A         ;Add to offset index for string
  594 0000016A 1C40            ADDS             R0, R0, #1
  595 0000016C         
  596 0000016C E7F4            B                READ_CHAR
  597 0000016E         
  598 0000016E         END_PUT_STR
  599 0000016E         
  600 0000016E         ;Pop PC returns nested subroutine
  601 0000016E         ;Return with pointer at last char of string in R0
  602 0000016E BD0A            POP              {R1, R3, PC}
  603 00000170         
  604 00000170         ;--------------------------------------------
  605 00000170         
  606 00000170         
  607 00000170         ;R0 = memory location of string 
  608 00000170         ;R1 = Buffer capacity (numChars)
  609 00000170         ;R2 = Output num of String length
  610 00000170         LengthStringSB
  611 00000170         ;--------------------------------------------
  612 00000170         
  613 00000170 B51A            PUSH             {R1, R3, R4, LR}
  614 00000172 214F            MOVS             R1, #MAX_STRING
  615 00000174 2200            MOVS             R2, #0      ; Initalize length 
                                                            to zero.



ARM Macro Assembler    Page 13 Exercise 07 Circular FIFO Queue Operations


  616 00000176 2400            MOVS             R4, #0      ; Initalize STR off
                                                            set to zero
  617 00000178         
  618 00000178         ADD_TO_LEN
  619 00000178         
  620 00000178         ;if legth is >= buffer, return
  621 00000178 428A            CMP              R2, R1
  622 0000017A DA05            BGE              END_GET_LEN
  623 0000017C         
  624 0000017C         ;Grab the next character of input and store in R3
  625 0000017C 5D03            LDRB             R3, [R0, R4]
  626 0000017E         
  627 0000017E         ;check if character is a null terminator
  628 0000017E 2B00            CMP              R3, #0
  629 00000180 D002            BEQ              END_GET_LEN
  630 00000182         
  631 00000182         ;Add to string offset
  632 00000182 1C64            ADDS             R4, R4, #1
  633 00000184         ;Add 1 to max
  634 00000184 1C52            ADDS             R2, R2, #1
  635 00000186         
  636 00000186 E7F7            B                ADD_TO_LEN
  637 00000188         
  638 00000188         END_GET_LEN
  639 00000188         
  640 00000188         ;Pop PC returns nested subroutine
  641 00000188 BD1A            POP              {R1, R3, R4, PC}
  642 0000018A         
  643 0000018A         ;--------------------------------------------
  644 0000018A         
  645 0000018A         DIVU
  646 0000018A         ;--------------------------------------------
  647 0000018A B40C            PUSH             {R2,R3}     ; Preserve state of
                                                             Registers, will be
                                                             using for computat
                                                            ion
  648 0000018C 2800            CMP              R0, #0
  649 0000018E D000            BEQ              SET_C
  650 00000190 E007            B                NO_ERR
  651 00000192         
  652 00000192         SET_C
  653 00000192         
  654 00000192 F3EF 8200       MRS              R2, APSR
  655 00000196 2320            MOVS             R3, #0x20
  656 00000198 061B            LSLS             R3, R3, #24
  657 0000019A 431A            ORRS             R2, R2, R3
  658 0000019C F382 8800       MSR              APSR, R2
  659 000001A0         
  660 000001A0 E00D            B                RETURN
  661 000001A2         NO_ERR
  662 000001A2 2200            MOVS             R2, #0      ; Move beginning qu
                                                            otient to R2
  663 000001A4         
  664 000001A4         DIVIDE_OP
  665 000001A4 4281            CMP              R1, R0
  666 000001A6 D302            BLO              END_DIVIDE_WHILE
  667 000001A8         
  668 000001A8 1A09            SUBS             R1, R1, R0  ; R1 = dividend - d
                                                            ivisor



ARM Macro Assembler    Page 14 Exercise 07 Circular FIFO Queue Operations


  669 000001AA 1C52            ADDS             R2, R2, #1  ; Quotient += 1
  670 000001AC         
  671 000001AC E7FA            B                DIVIDE_OP
  672 000001AE         
  673 000001AE         END_DIVIDE_WHILE
  674 000001AE 0010            MOVS             R0, R2
  675 000001B0         
  676 000001B0 F3EF 8200       MRS              R2, APSR
  677 000001B4 2320            MOVS             R3, #0x20
  678 000001B6 0612            LSLS             R2, R2, #24
  679 000001B8 439A            BICS             R2, R2, R3
  680 000001BA F382 8800       MSR              APSR, R2
  681 000001BE         
  682 000001BE         RETURN
  683 000001BE BC0C            POP              {R2, R3}    ;Return registers t
                                                            o previous state
  684 000001C0 4770            BX               LR          ;Jump out of subrou
                                                            tine
  685 000001C2         
  686 000001C2         ;--------------------------------------------
  687 000001C2         
  688 000001C2         Init_UART0_Polling
  689 000001C2         ;--------------------------------------------
  690 000001C2         ;Allocate R0-2 for Ri=k 
  691 000001C2         ;Store prevoius values for restoration
  692 000001C2 B407            PUSH             {R0, R1, R2}
  693 000001C4         
  694 000001C4         ;Select MCGPLLCLK / 2 as UART0 clock source
  695 000001C4 481D            LDR              R0,=SIM_SOPT2
  696 000001C6 491E            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  697 000001C8 6802            LDR              R2,[R0,#0]
  698 000001CA 438A            BICS             R2,R2,R1
  699 000001CC 491D            LDR              R1,=SIM_SOPT2_UART0_MCGPLLCLK_D
IV2
  700 000001CE 430A            ORRS             R2,R2,R1
  701 000001D0 6002            STR              R2,[R0,#0]
  702 000001D2         ;Enable external connection for UART0
  703 000001D2 481D            LDR              R0,=SIM_SOPT5
  704 000001D4 491D            LDR              R1,= SIM_SOPT5_UART0_EXTERN_MAS
K_CLEAR
  705 000001D6 6802            LDR              R2,[R0,#0]
  706 000001D8 438A            BICS             R2,R2,R1
  707 000001DA 6002            STR              R2,[R0,#0]
  708 000001DC         ;Enable clock for UART0 module
  709 000001DC 481C            LDR              R0,=SIM_SCGC4
  710 000001DE 491D            LDR              R1,= SIM_SCGC4_UART0_MASK
  711 000001E0 6802            LDR              R2,[R0,#0]
  712 000001E2 430A            ORRS             R2,R2,R1
  713 000001E4 6002            STR              R2,[R0,#0]
  714 000001E6         ;Enable clock for Port A module
  715 000001E6 481C            LDR              R0,=SIM_SCGC5
  716 000001E8 491C            LDR              R1,= SIM_SCGC5_PORTA_MASK
  717 000001EA 6802            LDR              R2,[R0,#0]
  718 000001EC 430A            ORRS             R2,R2,R1
  719 000001EE 6002            STR              R2,[R0,#0]
  720 000001F0         ;Connect PORT A Pin 1 (PTA1) to UART0 Rx (J1 Pin 02)
  721 000001F0 481B            LDR              R0,=PORTA_PCR1
  722 000001F2 491C            LDR              R1,=PORT_PCR_SET_PTA1_UART0_RX
  723 000001F4 6001            STR              R1,[R0,#0]



ARM Macro Assembler    Page 15 Exercise 07 Circular FIFO Queue Operations


  724 000001F6         ;Connect PORT A Pin 2 (PTA2) to UART0 Tx (J1 Pin 04)
  725 000001F6 481C            LDR              R0,=PORTA_PCR2
  726 000001F8 491A            LDR              R1,=PORT_PCR_SET_PTA2_UART0_TX
  727 000001FA 6001            STR              R1,[R0,#0]
  728 000001FC         
  729 000001FC         ;Disable UART0 receiver and transmitter
  730 000001FC 480E            LDR              R0,=UART0_BASE
  731 000001FE 210C            MOVS             R1,#UART0_C2_T_R
  732 00000200 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  733 00000202 438A            BICS             R2,R2,R1
  734 00000204 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  735 00000206         ;Set UART0 for 9600 baud, 8N1 protocol
  736 00000206 2101            MOVS             R1,#UART0_BDH_9600
  737 00000208 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  738 0000020A 2138            MOVS             R1,#UART0_BDL_9600
  739 0000020C 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]
  740 0000020E 2100            MOVS             R1,#UART0_C1_8N1
  741 00000210 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  742 00000212 2100            MOVS             R1,#UART0_C3_NO_TXINV
  743 00000214 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  744 00000216 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  745 00000218 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  746 0000021A 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  747 0000021C 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  748 0000021E 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  749 00000220 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  751 00000222 21C0            MOVS             R1,               #UART0_S2_NO
_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
  752 00000224 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  753 00000226         
  754 00000226         ;Enable UART0 receiver and transmitter
  755 00000226 210C            MOVS             R1,#UART0_C2_T_R
  756 00000228 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  757 0000022A         
  758 0000022A         ;Pop prevous R0-2 values off the stack.
  759 0000022A BC07            POP              {R0, R1, R2}
  760 0000022C         
  761 0000022C 4770            BX               LR
  762 0000022E         
  763 0000022E         ;-------------------------------------------------------
                       ------------
  764 0000022E         
  765 0000022E         ;>>>>>   end subroutine code <<<<<
  766 0000022E 00 00           ALIGN
  767 00000230         ;*******************************************************
                       *********
  768 00000230         ;Vector Table Mapped to Address 0 at Reset
  769 00000230         ;Linker requires __Vectors to be exported
  770 00000230 00000000 
              00000000 
              4006A000 
              40048004 
              0C000000 
              04010000 
              40048010 
              00010007 
              40048034 
              00000400 
              40048038 



ARM Macro Assembler    Page 16 Exercise 07 Circular FIFO Queue Operations


              00000200 
              40049004 
              01000200 
              40049008         AREA             RESET, DATA, READONLY
  771 00000000                 EXPORT           __Vectors
  772 00000000                 EXPORT           __Vectors_End
  773 00000000                 EXPORT           __Vectors_Size
  774 00000000                 IMPORT           __initial_sp
  775 00000000                 IMPORT           Dummy_Handler
  776 00000000         __Vectors
  777 00000000         ;ARM core vectors
  778 00000000 00000000        DCD              __initial_sp ;00:end of stack
  779 00000004 00000000        DCD              Reset_Handler ;01:reset vector
  780 00000008 00000000        DCD              Dummy_Handler ;02:NMI
  781 0000000C 00000000        DCD              Dummy_Handler ;03:hard fault
  782 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
  783 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
  784 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
  785 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
  786 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
  787 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
  788 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
  789 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (super
                                                            visor call)
  790 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
  791 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
  792 00000038 00000000        DCD              Dummy_Handler ;14:PendableSrvRe
                                                            q (pendable request
                                                             
  793 0000003C         ;   for system service)
  794 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (syst
                                                            em tick timer)
  795 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0
                                                             xfer complete/erro
                                                            r
  796 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1
                                                             xfer complete/erro
                                                            r
  797 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2
                                                             xfer complete/erro
                                                            r
  798 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3
                                                             xfer complete/erro
                                                            r
  799 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
  800 00000054 00000000        DCD              Dummy_Handler ;21:command compl
                                                            ete; read collision
                                                            
  801 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage d
                                                            etect;
  802 0000005C         ;   low-voltage warning
  803 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage w
                                                            akeup
  804 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
  805 00000064 00000000        DCD              Dummy_Handler ;25:I2C1
  806 00000068 00000000        DCD              Dummy_Handler ;26:SPI0 (all IRQ
                                                             sources)
  807 0000006C 00000000        DCD              Dummy_Handler ;27:SPI1 (all IRQ
                                                             sources)



ARM Macro Assembler    Page 17 Exercise 07 Circular FIFO Queue Operations


  808 00000070 00000000        DCD              Dummy_Handler ;28:UART0 (status
                                                            ; error)
  809 00000074 00000000        DCD              Dummy_Handler ;29:UART1 (status
                                                            ; error)
  810 00000078 00000000        DCD              Dummy_Handler ;30:UART2 (status
                                                            ; error)
  811 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
  812 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
  813 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
  814 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
  815 0000008C 00000000        DCD              Dummy_Handler ;35:TPM2
  816 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
  817 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
                                                            
  818 00000098 00000000        DCD              Dummy_Handler ;38:PIT (all IRQ 
                                                            sources)
  819 0000009C 00000000        DCD              Dummy_Handler ;39:I2S0
  820 000000A0 00000000        DCD              Dummy_Handler ;40:USB0
  821 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
  822 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
  823 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
  824 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
  825 000000B4 00000000        DCD              Dummy_Handler ;45:Segment LCD
  826 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA pin det
                                                            ect
  827 000000BC 00000000        DCD              Dummy_Handler ;47:PORTC and POR
                                                            TD pin detect
  828 000000C0         __Vectors_End
  829 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
  830 000000C0                 ALIGN
  831 000000C0         ;*******************************************************
                       *********
  832 000000C0         ;Constants
  833 000000C0                 AREA             MyConst,DATA,READONLY
  834 00000000         ;>>>>> begin constants here <<<<<
  835 00000000 54 79 70 
              65 20 61 
              20 73 74 
              72 69 6E 
              67 20 63 
              6F 6D 6D 
              61 6E 64 
              20 28 67 
              2C 20 69 
              2C 20 6C 
              2C 20 70 
              29 3A 00 Prompt  DCB              "Type a string command (g, i, l
, p):", 0
  836 00000024 4C 65 6E 
              67 74 68 
              3A 20 00 Length  DCB              "Length: ", 0
  837 0000002D         ;>>>>>   end constants here <<<<<
  838 0000002D 00 00 00        ALIGN
  839 00000030         ;*******************************************************
                       *********
  840 00000030         ;Variables
  841 00000030                 AREA             MyData,DATA,READWRITE



ARM Macro Assembler    Page 18 Exercise 07 Circular FIFO Queue Operations


  842 00000000         ;>>>>> begin variables here <<<<<
  843 00000000         
  844 00000000         ;Memory allocated to store String input from user
  845 00000000 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    Queue   SPACE            Q_BUF_SZ
  846 00000050         ;6 Byte buffer to store queue information 
  847 00000050 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 QueueRecord
                               SPACE            Q_REC_SZ
  848 00000062         
  849 00000062         ;>>>>>   end variables here <<<<<
  850 00000062 00 00           ALIGN
  851 00000064                 END
Command Line: --debug --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --
depend=.\objects\queue.d -o.\objects\queue.o -IC:\Users\jmp3833\Desktop\arm-lib
s\Exercise07\RTE -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.6.0\Device\Inclu
de -IC:\Keil_v5\ARM\CMSIS\Include --predefine="__UVISION_VERSION SETA 515" --pr
edefine="MKL46Z256xxx4 SETA 1" --list=.\listings\queue.lst Queue.s
